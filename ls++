#!/usr/bin/perl
use strict;
use open qw/:std :utf8/;
use utf8;
use Getopt::Long;
use Pod::Usage;
use Data::Dumper::Concise;

my $DEBUG = 1;


my $config = "$ENV{XDG_CONFIG_HOME}/ls++/ls++.conf";

($DEBUG) ? require('./ls++.conf') : require($config);
if($@) {
  die($@);
}

# Imported from config
our(
  # The @c array is alredy imported ↑
  @c,
  @d,           # delimiters
  $color256,    # 256 color support?
  $colorscheme, # colorscheme to use?
  $padding_z,   # size padding
  @ignores,     # files to be ignored
  $ln_arrow,    # symlink arrow
  $ln_color,    # symlink arrow color
  %ft_colors    #
);


our(
  $opt_view_perm_file,
  $opt_view_perm_size_file,
  $opt_view_time_perm_file,
  $opt_view_time_perm_size_file,
  $opt_view_perm_time_size_file,
);

GetOptions(
  pf    => \$opt_view_perm_file,
  psf   => \$opt_view_perm_size_file,
  tpf   => \$opt_view_time_perm_file,
  tpsf  => \$opt_view_time_perm_size_file,
  ptsf  => \$opt_view_perm_time_size_file,

  help  => sub { pod2usage(verbose => 1); },
  man   => sub { pod2usage(verbose => 2); },
);

if(!@ARGV) {
  @ARGV = './';
}

@d = map { $_ = "$c[0]$_$c[16]" } @d;

my $curtime = time();

my $ls_cmd = 'ls -hAlv'
  . ' --group-directories-first --color=always --time=ctime --time-style=+%s';

open(my $ls, '-|', "$ls_cmd '@ARGV'") or die($!);

while(<$ls>) {
  s/->/$ln_color$ln_arrow$c[16]/; # FIXME

  next if /^total/;
  my ($perm, $hlink, $user, $group, $size, $seconds) = split(/\s+/);

  ## parse filename separetly to allow for whitespace etc.
  my ($file) = m/.* \d{6,}? (.*)/;

  if($file =~ join(' ', @ignores)) {
    # ignore those files and skip to next
    next;
  }

  for my $re(keys(%ft_colors)) {
    if($file =~ m/$re/i) {
      $file =~ s|\e\[[0-9;]+m||; # remove LS_COLORS
      $file = "$ft_colors{$re}$file\e[0m";
    }
  }

  ## calculate relative time
  my ($rel) = relative(time(), $seconds);

  ## color size
  $size = size($size);

  ## color permissions
  $perm = perm($perm);

  ## views

  if($opt_view_perm_file) {
    perm_file($perm, $file);
  }
  elsif($opt_view_perm_size_file) {
    perm_size_file($perm, $size, $file);
  }
  elsif($opt_view_time_perm_file) {
    time_perm_size_file($perm, $rel, $size, $file);
  }
  elsif($opt_view_perm_size_file) {
    time_perm_size_file($perm, $rel, $size, $file);
  }
  else {
    perm_time_size_file($perm, $rel, $size, $file)
  }
  #left_file($file, $size, 50);
  #right_file($size, $file, 50);
}
close($ls);


## colorizes permissions
sub perm {
  my ($perm) = @_;

  $perm =~ s/-/$d[1]/g;
  $perm =~ s/(r)/$c[6]$1$c[16]/g;
  $perm =~ s/(w)/$c[7]$1$c[16]/g;
  $perm =~ s/(x)/$c[5]$1$c[16]/g;
  $perm =~ s/(d)/$c[3]$c[17]$1$c[16]/g;
  $perm =~ s/(l)/$c[8]$c[13]$1$c[16]/g;
  $perm =~ s/(s)/$c[11]$1$c[16]/g;
  $perm =~ s/(S)/$c[8]$1$c[16]/g;
  $perm =~ s/(t)/$c[8]$1$c[16]/g;
  $perm =~ s/(T)/$c[8]$c[17]$1$c[16]/g;

  return $perm;
}

## colors the size string depending on whether its K, M, G or prefixless
sub size {
  my ($size) = @_;

  return sprintf("% 39s", $size)
    if ($size =~ s/(.*)(K)/$c[2]$1$c[2]$c[17]$2$c[16]/);
  return sprintf("% 26s", $size)
    if ($size =~ s/(.*)(M)/$c[7]$1$c[17]$2$c[16]/);
  return $size if ($size =~ s/(.*)(G)/$c[3]$1$c[17]$2$c[16]/);
  return sprintf("% 26s", $size) # 1012B
    if ($size =~ s/(\d+)/$c[14]$1$c[17]B$c[16]/);
}

## calculates relative time from the current time in seconds
sub relative {
  my ($cur, $sec) = @_;
  my $delta = $cur - $sec;
  my ($unit, $ret);

  ## 0 < sec < 60
  $unit = "sec ";
  $ret = $delta;

  return relativef($c[3], "<", $unit)		if $delta < 10;
  return relativef($c[3], $ret, $unit)	if $delta < 60;

  ## 1 < min < 45
  $unit = "min ";
  $ret = int($ret/60);

  return relativef($c[15], "<", $unit)		if $delta < 2 * 60;
  return relativef($c[15], $ret, $unit)	if $delta < 45 * 60;

  ## 0.75 < hour < 42
  $unit = "hour";
  $ret = int($ret/60);

  return relativef($c[9], "<", $unit)		if $delta < 90 * 60;
  return relativef($c[9], $ret, $unit)	if $delta < 24 * 60 * 60;
  return relativef($c[9], $ret, $unit)	if $delta < 30 * 60 * 60;
  return relativef($c[9], $ret, $unit)	if $delta < 36 * 60 * 60;

  ## 0.75 < day < 30
  $unit = "day ";
  $ret = int($ret/24);

  return relativef($c[4], "<", $unit)		if $delta < 48 * 60 * 60;
  return relativef($c[4], $ret, $unit)	if $delta < 7 * 24 * 60 * 60;
  return relativef($c[4], $ret, $unit)	if $delta < 14 * 24 * 60 * 60;
  return relativef($c[4], $ret, $unit)	if $delta < 28 * 24 * 60 * 60;
  return relativef($c[4], $ret, $unit)	if $delta < 30 * 24 * 60 * 60;

  ## 1 < month < 12
  $unit = "mon ";
  $ret = int($ret/30);

  return relativef($c[14], "<", $unit)		if $delta < 2 * 30 * 24 * 60 * 60;
  return relativef($c[14], $ret, $unit)	if $delta < 12 * 30 * 24 * 60 * 60;

  ## 1 < years < inf
  $unit = "year";
  $ret = int($ret/12);

  return relativef($c[0], $ret, $unit);
}

## format for relative time
sub relativef {
  my ($color, $string, $unit) = @_;
  return sprintf("%s%-3s%-3s%s", $color, $string, $unit, $c[16]);
}

sub perm_file{
  my ($perm, $file) = @_;
  printf("%s%s%s%s\n", $d[0], $perm, $d[3], $file);
}

## view: permissions, size and filename
## | <perm> | <size> | <filename>
sub perm_size_file{
  my ($perm, $size, $file) = @_;
  printf("%s%s%s%-19s%s%s\n", $d[0], $perm, $d[3], $size, $d[2], $file);
}

## view: permissions, time, size and filename
## <time> | <perm> | <filename>
sub time_perm_file{
  my ($perm, $rel, $file) = @_;
  printf("%s%s%s%s%s\n", $rel, $d[0], $perm, $d[3], $file);
}

## view: time, permissions, size and filename
## <time> | <perm> | <size> | <filename>
sub time_perm_size_file{
  my ($perm, $rel, $size, $file) = @_;
  printf("%s%s%s%s%-${padding_z}s%s%s\n", $rel, $d[0], $perm, $d[3], $size, $d[2], $file);
}

## view: permissions, time, size and filename
## | <perm> | <size> | <filename>
sub perm_time_size_file{
  my ($perm, $rel, $size, $file) = @_;
  printf("%s %s%s%s%s%-${padding_z}s%s%s\n", $d[0], $perm, $d[3], $rel, $d[2], $size, $d[2], $file);
}

## view: file to the right
## <var> | <filename>
sub right_file{
  my ($var, $file, $paddingright) = @_;
  printf("%${paddingright}s%s%s\n", $var, $d[2], $file);
}

sub left_file{
  my ($file, $size, $paddingleft) = @_;

  ## first row has a \e[0m
  $file =~ s/^\e\[0m//g;

  my ($esclen, $strlen) = (0, length($file));

  ## for each escape sequence, pad the length of it
  while($file =~ m/\e\[(.*?m)/g) {
  	$esclen += length($1);
  }

  ## special symlink
  if($file =~ s/->/▻/) {
  	$esclen += 5;
  }

  my $padlen = $paddingleft - $strlen + $esclen;

  ## cut too long filenames
  if($padlen < 0) {
  	$file = substr($file, 0, $padlen-7);
  	$padlen = 0;
  	$file = $file . "...\e[0m";
  }

  # pad with spaces
  #$file = $file . ( ' ' x $padlen);
  $file = ( ' ' x $padlen) . $file;

  printf("%s%s%s\n", $file, $d[2], $size);
}




=pod

=head1 NAME

ls++ - colorized ls on steroids

=head1 USAGE

ls++ [view] (files)

=head1 DESCRIPTION


=head1 OPTIONS

=head3 Views

  --pf    permissions, file
  --psf   permissions, size, file
  --tpf   time, permissions, file
  --tpsf  time, permissions, size, file (default)
  --ptsf  permissions, time, size, file

  --help  show the help and exit
  --man   show the manpage and exit

=head1 HISTORY

I wanted to re-arrange the ls output just like one can do with the -printf
option to GNU find. Sadly, there are no -printf option available for ls, so I
threw together a quick hack called 'pilsner' that did what I wanted and nothing
more, nothing less. Not very useful to others.

Mattias Svanström crafted together the 'l' application which did basicly the
same thing but more elegant and with a nice twist; it calculated relative
mtimes.

I really liked that idea, but there were a couple of annoyances, so I forked the
project and added a configuration file, support for flags that'll control the
different views and possiblity to ignore certain files.

=head1 AUTHOR

Written by Magnus Woldrich

=head1 REPORTING BUGS

Report bugs to trapd00r@trapd00r.se

=head1 COPYRIGHT

Copyright (C) 2010 Magnus Woldrich

License GPLv2

=head1 SEE ALSO

B<l> <http://github.com/mmso/scripts>

=cut

