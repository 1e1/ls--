#!/usr/bin/perl
use vars qw($DEBUG $APP $VERSION);

$APP     = 'ls++';
$VERSION = 0.222;
use strict;
use open qw/:std :utf8/;
use utf8;
use Pod::Usage;
use Cwd 'abs_path';
use Getopt::Long;

#TODO Check for $DISPLAY, and use ansi colors if missing
#TODO Use Term::ExtendedColor

#use Data::Dumper;
#$Data::Dumper::Terse     = 1;
#$Data::Dumper::Indent    = 1;
#$Data::Dumper::Useqq     = 1;
#$Data::Dumper::Deparse   = 1;
#$Data::Dumper::Quotekeys = 0;
#$Data::Dumper::Sortkeys  = 1;

if(!-t STDOUT ) {
  system('/bin/ls', @ARGV); # ls -1
  exit;
}

config_init();

# Imported from config
our(
  @c,
  @d,           # delimiters
  $color256,    # 256 color support?
  $colorscheme, # colorscheme to use?
  $padding_z,   # size padding
  @ignores,     # files to be ignored
  $ln_arrow,    # symlink arrow
  $ln_color,    # symlink arrow color
  %ft_colors,   # for LS_COLORS type of coloring
  %match_files, # colorize specific patterns
);

our($opt_pf, $opt_psf, $opt_tpf, $opt_tpsf, $opt_ptsf);
GetOptions(
  'pf'      => \$opt_pf,
  'psf'     => \$opt_psf,
  'tpf'     => \$opt_tpf,
  'tpsf'    => \$opt_tpsf,
  'ptsf'    => \$opt_ptsf,

  'ansi'=> sub {
    $color256 = 0;
    @c = (
      "\e[30m",   # NULL              black
      "\e[30;1m", # NULL              bright black
      "\e[31m",   # K                 red
      "\e[31;1m", # G, sec            bright red
      "\e[32m",   # day               green
      "\e[32;1m", # +x                bright green
      "\e[33m",   # +r                yellow
      "\e[33;1m", # +w, M             bright yellow
      "\e[34m",   # other             blue
      "\e[34;1m", # hour              bright blue
      "\e[35m",   #                   magenta
      "\e[35;1m", # +s                bright magenta
      "\e[36m",   #                   cyan
      "\e[36;1m", # link              bright cyan
      "\e[37m",   # B, month, delim   white

      "\e[33;1m", #
      "\e[0m",    #                   default
      "\e[1m",    # Various           bold
      );
    },
  'help'     => sub { print "$APP $VERSION\n\n"; pod2usage(verbose => 1); },
  'man'      => sub { pod2usage(verbose => 2); },
);


my $curtime = time();
my ($perm, $hlink, $user, $group, $size, $seconds, $file, $rel);

($color256) ? map { $_ = "$c[0]$_$c[16]" } @d : map { $_ = "$c[1]$_$c[16]" } @d;

sub is_file {
  my $what = shift;
  return 1 if(-e $what);
}

do {
  my $i = 0;
  for(@c) {
    printf("%s \$c[$i]\e[0m\n", $_);
    $i++;
  }
  $i = 0;
  for(@d) {
    printf("%s \$d[$i]\n", $_, $i);
    $i++;
  }
} if($DEBUG);

my @ls_where = ();

my $cmd = undef;
for(@ARGV) {
  if(is_file($_)) {
    push(@ls_where, "'$_'");
  }
  else {
    $cmd = shift;
  }
}
@ls_where = './' if(!@ls_where);


=for OS

Mac OS / BSD ls differs from GNU coreutils ls:

BSD   options: -hAlvGc
Linux options: --hAlv --group-directories-first --color=always --time=ctime
               --time-style=+%s


BSD output:

-rw-r--r--  1 trapd00r  staff   3.8K Dec 21 09:24 ls++.conf

Coreutils output:

-rw-r--r-- 1 scp1 users 4.0K 1292738451 ls++.conf

There's no way the BSD ls could output ctime for a file, it seems.
This makes calculating relative times difficult. Not sure how to solve this.

=cut

my $ls_cmd;

# Make the coreutils cmdline the default for now...
$ls_cmd = 'ls -hAlv'
  . ' --group-directories-first --color=always --time=ctime --time-style=+%s';


if($^O eq 'darwin') {
  # Cover MacOS.
  $ls_cmd = 'ls -hAlvGc';
}

open(my $ls, '-|', "$ls_cmd @ls_where") or die($!);



while(<$ls>) {
  s/->/$ln_color$ln_arrow$c[16]/; # FIXME

  next if(/^total/);

  if(/^(.+):$/) { # /tmp: , .:
    my $where = abs_path($1); # resolve ./, $HOME etc
    printf("$c[10] >\e[1m$c[9]>\e[0m %s\n", $where);
    next;
  }


  if($^O eq 'linux') {
    ($perm, $hlink, $user, $group, $size, $seconds) = split(/\s+/)
      unless(/^\s+/); # /tmp:

    ## parse filename separetly to allow for whitespace etc.
    ($file) = m/.* \d{6,}? (.*)/;

    next if($file =~ join(' ', @ignores));
  }
  elsif($^O eq 'darwin') {
    ($perm, $hlink, $user, $group, $size) = split(/\s+/, $_);

    ($file) = $_ =~ m/.*\d{2,}? (.*)/;

    $perm =~ s/(?:\+|\@)$//g; # MacOS 'special extended attributes'

    next if($file =~ join(' ', @ignores));
  }

  next if !$file;

  for my $match(keys(%match_files)) {
    if($file =~ m/$match/) {
      $file =~ s$(?:\e|\033)\[[0-9;]+m$$; # remove LS_COLORS
      $file = "$match_files{$match}$file\e[0m";
    }
  }

  for my $re(keys(%ft_colors)) {
    if($file =~ m/$re/) {
      $file =~ s$(?:\e|\033)\[[0-9;]+m$$; # remove LS_COLORS
      $file = "$ft_colors{$re}$file\e[0m";
    }
  }

  ## calculate relative time

  if($^O eq 'darwin') {
    $rel = 'foo'; # Do a stat() on every file...
  }
  else {
    ($rel) = relative(time(), $seconds);
  }



  ## color permissions
  $perm = perm($perm);

  if($^O eq 'darwin') {
    if($size) {
      ## color size
      $size = size($size);
      $size =~ s/\s{6}//;
    }
    if(!$size) {
      $size = "\0" x 40 . "    ";

    }
    #NOTE
    # This is the only mode that's supported on BSDs for now
    perm_size_file($perm, $size, $file);
    #print "$size\n";
    next;
  }
  else {
    $size = size($size);
    $size =~ s/^\s{3}(.+)/$1 /;
    #if(length($size) == 1) {
    #  $size = "  $size  ";
    #}
    #elsif(length($size) == 2) {
    #  $size = " $size  ";
    #}
    #elsif(length($size) == 3) {
    #  $size = " $size ";
    #}
    #elsif(length($size) == 4) {
    #  $size = "$size ";
    #}
  }


  ## views

  if($opt_pf) {
    perm_file($perm, $file);
  }
  elsif($opt_psf) {
    perm_size_file($perm, $size, $file);
  }
  elsif($opt_tpf) {
    time_perm_file($rel, $perm, $file);
  }
  elsif($opt_tpsf) {
    time_perm_size_file($rel, $perm, $size, $file);
  }
  elsif($opt_ptsf) {
    perm_time_size_file($perm, $rel, $size, $file);
  }
  else {
    perm_time_size_file($perm, $rel,  $size, $file);
  }
}
close($ls);


## colorizes permissions
sub perm {
  my ($perm) = @_;

  $perm =~ s/-/$d[1]/g;
  $perm =~ s/(r)/$c[6]$1$c[16]/g;
  $perm =~ s/(w)/$c[7]$1$c[16]/g;
  $perm =~ s/(x)/$c[5]$1$c[16]/g;
  $perm =~ s/(d)/$c[3]$c[17]$1$c[16]/g;
  $perm =~ s/(l)/$c[8]$c[13]$1$c[16]/g;
  $perm =~ s/(s)/$c[11]$1$c[16]/g;
  $perm =~ s/(S)/$c[8]$1$c[16]/g;
  $perm =~ s/(t)/$c[8]$1$c[16]/g;
  $perm =~ s/(T)/$c[8]$c[17]$1$c[16]/g;

  return $perm;
}

## colors the size string depending on whether its K, M, G or prefixless
sub size {
  my ($size) = @_;

  if($color256) {
    #$size =~ s/(\S+)(K)/$c[2]$1\e[0m$c[4]$2\e[0m/gi;# and print "AA\n";

    # MacOS, BSD
    if($^O eq 'darwin') {
      return sprintf("% 40s", $size)
        if ($size =~ s/^\s*(.*)(K)$/$c[2]$1$c[2]$c[17]$2$c[16]/);
        # 23 MacOS
        # 27 GNU
      return sprintf("% 23s", $size)
        if ($size =~ s/^(.*)(M)$/$c[7]$1$c[17]$2$c[16]/);
      return sprintf("% 27s", $size)
        if ($size =~ s/^(.*)(G)$/$c[3]$1$c[17]$2$c[16]/);
      return sprintf("% 27s", $size) # 1012B
        if ($size =~ s/^(\d+)$/$c[14]$1$c[17]B$c[16]/);
    }
    # GNU
    else {
      return sprintf("% 38s", $size)
        if ($size =~ s/^\s*(.*)(K)$/$c[2]$1$c[2]$c[17]$2$c[16]/);
      return sprintf("% 27s", $size)
        if ($size =~ s/^(.*)(M)$/$c[7]$1$c[17]$2$c[16]/);
      return sprintf("% 29s", $size)
        if ($size =~ s/^(.*)(G)$/$c[3]$1$c[17]$2$c[16]/);
      return sprintf("% 27s", $size) # 1012B
        if ($size =~ s/^(\d+)$/$c[14]$1$c[17]B$c[16]/);
    }
  }

  # ANSI
  else {
    return sprintf("% 26s", $size)
      if ($size =~ s/(.*)(K)/$c[2]$1$c[2]$c[17]$2$c[16]/);
    return sprintf("% 23s", $size)
      if ($size =~ s/(.*)(M)/$c[7]$1$c[17]$2$c[16]/);
    return sprintf("% 23s", $size)
      if ($size =~ s/(.*)(G)/$c[3]$1$c[17]$2$c[16]/);
    return sprintf("% 21s", $size) # 1012B
      if ($size =~ s/(\d+)/$c[14]$1$c[17]B$c[16]/);
  }
}



## calculates relative time from the current time in seconds
sub relative {
  my ($cur, $sec) = @_;
  my $delta = $cur - $sec;
  my ($unit, $ret);

  ## 0 < sec < 60
  $unit = "sec ";
  $ret = $delta;

  return relativef($c[3], "<", $unit)   if $delta < 10;
  return relativef($c[3], $ret, $unit)  if $delta < 60;

  ## 1 < min < 45
  $unit = "min ";
  $ret = int($ret/60);

  return relativef($c[15], "<", $unit)    if $delta < 2 * 60;
  return relativef($c[15], $ret, $unit) if $delta < 45 * 60;

  ## 0.75 < hour < 42
  $unit = "hour";
  $ret = int($ret/60);

  return relativef($c[9], "<", $unit)   if $delta < 90 * 60;
  return relativef($c[9], $ret, $unit)  if $delta < 24 * 60 * 60;
  return relativef($c[9], $ret, $unit)  if $delta < 30 * 60 * 60;
  return relativef($c[9], $ret, $unit)  if $delta < 36 * 60 * 60;

  ## 0.75 < day < 30
  $unit = "day ";
  $ret = int($ret/24);

  return relativef($c[4], "<", $unit)   if $delta < 48 * 60 * 60;
  return relativef($c[4], $ret, $unit)  if $delta < 7 * 24 * 60 * 60;
  return relativef($c[4], $ret, $unit)  if $delta < 14 * 24 * 60 * 60;
  return relativef($c[4], $ret, $unit)  if $delta < 28 * 24 * 60 * 60;
  return relativef($c[4], $ret, $unit)  if $delta < 30 * 24 * 60 * 60;

  ## 1 < month < 12
  $unit = "mon ";
  $ret = int($ret/30);

  return relativef($c[14], "<", $unit)    if $delta < 2 * 30 * 24 * 60 * 60;
  return relativef($c[14], $ret, $unit) if $delta < 12 * 30 * 24 * 60 * 60;

  ## 1 < years < inf
  $unit = "year";
  $ret = int($ret/12);

  return relativef($c[0], $ret, $unit);
}

## format for relative time
sub relativef {
  my ($color, $string, $unit) = @_;
  return sprintf("%s%-3s%-3s%s", $color, $string, $unit, $c[16]);
}

sub perm_file {
  my ($perm, $file) = @_;
  printf("%s%s%s%s\n", $d[0], $perm, $d[3], $file);
}

## view: permissions, size and filename
## | <perm> | <size> | <filename>
sub perm_size_file {
  my ($perm, $size, $file) = @_;
  if($^O eq 'darwin') {
    if(length($size) == 38) {
      #$size = " $size ";
    }
    elsif(length($size) == 37) {
      $size .= ' ';
    }
    elsif(length($size) == 24) {
      $size = "            $size            ";
    }
    else {
    }
    printf("%s%s%s%s%s%s\n", $d[0], $perm, $d[3], $size, $d[2], $file);
  }
  else {
    printf("%s%s%s%19s%s%s\n", $d[0], $perm, $d[3], $size, $d[2], $file);
  }
}

## view: permissions, time, size and filename
## <time> | <perm> | <filename>
sub time_perm_file {
  my ($perm, $rel, $file) = @_;
  printf("%s%s%s%s%s\n", $rel, $d[0], $perm, $d[3], $file);
}

## view: time, permissions, size and filename
## <time> | <perm> | <size> | <filename>
sub time_perm_size_file {
  my ($perm, $rel, $size, $file) = @_;
  printf("%s%s%s%s%s%s%s\n", $rel, $d[0], $perm, $d[3], $size, $d[2], $file);
}

## view: permissions, time, size and filename
## | <perm> | <size> | <filename>
sub perm_time_size_file {
  my ($perm, $rel, $size, $file) = @_;
  printf("%s %s%s%s%s%s%s%s\n", $d[0], $perm, $d[3], $rel, $d[2], $size, $d[2], $file);
}

## view: file to the right
## <var> | <filename>
sub right_file {
  my ($var, $file, $paddingright) = @_;
  printf("%${paddingright}s%s%s\n", $var, $d[2], $file);
}

sub left_file {
  my ($file, $size, $paddingleft) = @_;

  ## first row has a \e[0m
  $file =~ s/^\e\[0m//g;

  my ($esclen, $strlen) = (0, length($file));

  ## for each escape sequence, pad the length of it
  while($file =~ m/\e\[(.*?m)/g) {
    $esclen += length($1);
  }

  ## special symlink
  if($file =~ s/->/▻/) {
    $esclen += 5;
  }

  my $padlen = $paddingleft - $strlen + $esclen;

  ## cut too long filenames
  if($padlen < 0) {
    $file = substr($file, 0, $padlen-7);
    $padlen = 0;
    $file = $file . "...\e[0m";
  }

  # pad with spaces
  #$file = $file . ( ' ' x $padlen);
  $file = ( ' ' x $padlen) . $file;

  printf("%s%s%s\n", $file, $d[2], $size);
}
 
sub config_init {
  my $config;

  if($ENV{DEBUG}) {
    require("./ls++.conf");
    return;
  }

  if(-e "$ENV{HOME}/.config/ls++/ls++.conf") {
    $config = "$ENV{HOME}/.config/ls++/ls++.conf";
  }
  elsif(-e "$ENV{HOME}/.ls++.conf") {
    $config = "$ENV{HOME}/.ls++.conf";
  }
  elsif(-e "$ENV{HOME}/ls++.conf") {
    $config = "$ENV{HOME}/ls++.conf";
  }
  elsif(-e './ls++.conf') {
    $config = './ls++.conf';
  }
  elsif(-e '/etc/ls++.conf') {
    $config = '/etc/ls++.conf';
  }
  else {
    warn "No configuration file found.\n";
    exit 1;
  }
  print "Config found: $config\n" if($ENV{DEBUG});

  require($config);
  warn $@ if $@;
}

=pod




=pod

=head1 NAME

ls++ - colorized ls on steroids

=head1 USAGE

ls++ [view] (files)

=head1 DESCRIPTION

ls++ is what GNU ls would look like with extensive makeup applied.

=head1 OPTIONS

=head3 Views

  --pf    permissions, file
  --psf   permissions, size, file
  --tpf   time, permissions, file
  --tpsf  time, permissions, size, file (default)
  --ptsf  permissions, time, size, file

=head3 COLORS

  -ansi   use the standard ANSI colors

=head3 Documentation

  --help  show the help and exit
  --man   show the manpage and exit

=head1 HISTORY

I wanted to re-arrange the ls output just like one can do with the -printf
option to GNU find. Sadly, there are no -printf option available for ls, so I
threw together a quick hack called 'pilsner' that did what I wanted and nothing
more, nothing less. Not very useful to others.

Mattias Svanström crafted together the 'l' application which did basicly the
same thing but more elegant and with a nice twist; it calculated relative
mtimes.

I really liked that idea, but there were a couple of annoyances, so I forked the
project and added a configuration file, support for flags that'll control the
different views and possiblity to ignore certain files.

=head1 AUTHOR

Written by Magnus Woldrich

=head1 REPORTING BUGS

Report bugs to trapd00r@trapd00r.se

=head1 COPYRIGHT

Copyright (C) 2010 Magnus Woldrich

License GPLv2

=head1 SEE ALSO

B<l> <http://github.com/mmso/scripts>

=cut

