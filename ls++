#!/usr/bin/perl
use vars qw($DEBUG $APP $VERSION);

$APP     = 'ls++';
$VERSION = 0.215;
use strict;
use open qw/:std :utf8/;
use utf8;
use Pod::Usage;
use Cwd 'abs_path';
use Getopt::Long;

#use Data::Dumper;
#$Data::Dumper::Terse     = 1;
#$Data::Dumper::Indent    = 1;
#$Data::Dumper::Useqq     = 1;
#$Data::Dumper::Deparse   = 1;
#$Data::Dumper::Quotekeys = 0;
#$Data::Dumper::Sortkeys  = 1;

if(!-t STDOUT ) {
  system('/bin/ls', @ARGV); # ls -1
  exit;
}

my $config = "$ENV{XDG_CONFIG_HOME}/ls++/ls++.conf";

($DEBUG) ? require('./ls++.conf') : require($config);

# Imported from config
our(
  @c,
  @d,           # delimiters
  $color256,    # 256 color support?
  $colorscheme, # colorscheme to use?
  $padding_z,   # size padding
  @ignores,     # files to be ignored
  $ln_arrow,    # symlink arrow
  $ln_color,    # symlink arrow color
  %ft_colors,   # for LS_COLORS type of coloring
  %match_files, # colorize specific patterns
);

our($opt_pf, $opt_psf, $opt_tpf, $opt_tpsf, $opt_ptsf);
GetOptions(
  'pf'      => \$opt_pf,
  'psf'     => \$opt_psf,
  'tpf'     => \$opt_tpf,
  'tpsf'    => \$opt_tpsf,
  'ptsf'    => \$opt_ptsf,

  'ansi'=> sub {
    $color256 = 0;
    @c = (
      "\e[30m",   # NULL              black
      "\e[30;1m", # NULL              bright black
      "\e[31m",   # K                 red
      "\e[31;1m", # G, sec            bright red
      "\e[32m",   # day               green
      "\e[32;1m", # +x                bright green
      "\e[33m",   # +r                yellow
      "\e[33;1m", # +w, M             bright yellow
      "\e[34m",   # other             blue
      "\e[34;1m", # hour              bright blue
      "\e[35m",   #                   magenta
      "\e[35;1m", # +s                bright magenta
      "\e[36m",   #                   cyan
      "\e[36;1m", # link              bright cyan
      "\e[37m",   # B, month, delim   white

      "\e[33;1m", #
      "\e[0m",    #                   default
      "\e[1m",    # Various           bold
      );
    },
  'help'     => sub { print "$APP $VERSION\n\n"; pod2usage(verbose => 1); },
  'man'      => sub { pod2usage(verbose => 2); },
);


my $curtime = time();
my ($perm, $hlink, $user, $group, $size, $seconds, $file, $rel);

($color256) ? map { $_ = "$c[0]$_$c[16]" } @d : map { $_ = "$c[1]$_$c[16]" } @d;

sub is_file {
  my $what = shift;
  return 1 if(-e $what);
}

do {
  my $i = 0;
  for(@c) {
    printf("%s \$c[$i]\e[0m\n", $_);
    $i++;
  }
  $i = 0;
  for(@d) {
    printf("%s \$d[$i]\n", $_, $i);
    $i++;
  }
} if($DEBUG);

my @ls_where = ();

my $cmd = undef;
for(@ARGV) {
  if(is_file($_)) {
    push(@ls_where, "'$_'");
  }
  else {
    $cmd = shift;
  }
}
@ls_where = './' if(!@ls_where);


my $ls_cmd = 'ls -hAlv'
  . ' --group-directories-first --color=always --time=ctime --time-style=+%s';

open(my $ls, '-|', "$ls_cmd @ls_where") or die($!);

while(<$ls>) {
  s/->/$ln_color$ln_arrow$c[16]/; # FIXME

  next if(/^total/);

  if(/^(.+):$/) { # /tmp: , .:
    my $where = abs_path($1); # resolve ./, $HOME etc
    printf("$c[10]>\e[1m$c[9]>\e[0m %s\n", $where);
    next;
  }

  ($perm, $hlink, $user, $group, $size, $seconds) = split(/\s+/)
    unless(/^\s+/); # /tmp:

  ## parse filename separetly to allow for whitespace etc.
  ($file) = m/.* \d{6,}? (.*)/;

  next if($file =~ join(' ', @ignores));

  for my $match(keys(%match_files)) {
    if($file =~ m/$match/) {
      $file =~ s$(?:\e|\033)\[[0-9;]+m$$; # remove LS_COLORS
      $file = "$match_files{$match}$file\e[0m";
    }
  }

  for my $re(keys(%ft_colors)) {
    if($file =~ m/$re/) {
      $file =~ s$(?:\e|\033)\[[0-9;]+m$$; # remove LS_COLORS
      $file = "$ft_colors{$re}$file\e[0m";
    }
  }

  ## calculate relative time
  ($rel) = relative(time(), $seconds);

  ## color size
  $size = size($size);

  ## color permissions
  $perm = perm($perm);

  ## views

  if($opt_pf) {
    perm_file($perm, $file);
  }
  elsif($opt_psf) {
    perm_size_file($perm, $size, $file);
  }
  elsif($opt_tpf) {
    time_perm_file($rel, $perm, $file);
  }
  elsif($opt_tpsf) {
    time_perm_size_file($rel, $perm, $size, $file);
  }
  elsif($opt_ptsf) {
    perm_time_size_file($perm, $rel, $size, $file);
  }
  else {
    perm_time_size_file($perm, $rel,  $size, $file);
  }
}
close($ls);


## colorizes permissions
sub perm {
  my ($perm) = @_;

  $perm =~ s/-/$d[1]/g;
  $perm =~ s/(r)/$c[6]$1$c[16]/g;
  $perm =~ s/(w)/$c[7]$1$c[16]/g;
  $perm =~ s/(x)/$c[5]$1$c[16]/g;
  $perm =~ s/(d)/$c[3]$c[17]$1$c[16]/g;
  $perm =~ s/(l)/$c[8]$c[13]$1$c[16]/g;
  $perm =~ s/(s)/$c[11]$1$c[16]/g;
  $perm =~ s/(S)/$c[8]$1$c[16]/g;
  $perm =~ s/(t)/$c[8]$1$c[16]/g;
  $perm =~ s/(T)/$c[8]$c[17]$1$c[16]/g;

  return $perm;
}

## colors the size string depending on whether its K, M, G or prefixless
sub size {
  my ($size) = @_;

  if($color256) {
    return sprintf("% 40s", $size)
      if ($size =~ s/^(.*)(K)$/$c[2]$1$c[2]$c[17]$2$c[16]/);
    return sprintf("% 27s", $size)
      if ($size =~ s/^(.*)(M)$/$c[7]$1$c[17]$2$c[16]/);
    return sprintf("% 27s", $size)
      if ($size =~ s/^(.*)(G)$/$c[3]$1$c[17]$2$c[16]/);
    return sprintf("% 27s", $size) # 1012B
      if ($size =~ s/^(\d+)$/$c[14]$1$c[17]B$c[16]/);
  }
  else {
    return sprintf("% 26s", $size)
      if ($size =~ s/(.*)(K)/$c[2]$1$c[2]$c[17]$2$c[16]/);
    return sprintf("% 23s", $size)
      if ($size =~ s/(.*)(M)/$c[7]$1$c[17]$2$c[16]/);
    return sprintf("% 23s", $size)
      if ($size =~ s/(.*)(G)/$c[3]$1$c[17]$2$c[16]/);
    return sprintf("% 21s", $size) # 1012B
      if ($size =~ s/(\d+)/$c[14]$1$c[17]B$c[16]/);
    }
}



## calculates relative time from the current time in seconds
sub relative {
  my ($cur, $sec) = @_;
  my $delta = $cur - $sec;
  my ($unit, $ret);

  ## 0 < sec < 60
  $unit = "sec ";
  $ret = $delta;

  return relativef($c[3], "<", $unit)		if $delta < 10;
  return relativef($c[3], $ret, $unit)	if $delta < 60;

  ## 1 < min < 45
  $unit = "min ";
  $ret = int($ret/60);

  return relativef($c[15], "<", $unit)		if $delta < 2 * 60;
  return relativef($c[15], $ret, $unit)	if $delta < 45 * 60;

  ## 0.75 < hour < 42
  $unit = "hour";
  $ret = int($ret/60);

  return relativef($c[9], "<", $unit)		if $delta < 90 * 60;
  return relativef($c[9], $ret, $unit)	if $delta < 24 * 60 * 60;
  return relativef($c[9], $ret, $unit)	if $delta < 30 * 60 * 60;
  return relativef($c[9], $ret, $unit)	if $delta < 36 * 60 * 60;

  ## 0.75 < day < 30
  $unit = "day ";
  $ret = int($ret/24);

  return relativef($c[4], "<", $unit)		if $delta < 48 * 60 * 60;
  return relativef($c[4], $ret, $unit)	if $delta < 7 * 24 * 60 * 60;
  return relativef($c[4], $ret, $unit)	if $delta < 14 * 24 * 60 * 60;
  return relativef($c[4], $ret, $unit)	if $delta < 28 * 24 * 60 * 60;
  return relativef($c[4], $ret, $unit)	if $delta < 30 * 24 * 60 * 60;

  ## 1 < month < 12
  $unit = "mon ";
  $ret = int($ret/30);

  return relativef($c[14], "<", $unit)		if $delta < 2 * 30 * 24 * 60 * 60;
  return relativef($c[14], $ret, $unit)	if $delta < 12 * 30 * 24 * 60 * 60;

  ## 1 < years < inf
  $unit = "year";
  $ret = int($ret/12);

  return relativef($c[0], $ret, $unit);
}

## format for relative time
sub relativef {
  my ($color, $string, $unit) = @_;
  return sprintf("%s%-3s%-3s%s", $color, $string, $unit, $c[16]);
}

sub perm_file {
  my ($perm, $file) = @_;
  printf("%s%s%s%s\n", $d[0], $perm, $d[3], $file);
}

## view: permissions, size and filename
## | <perm> | <size> | <filename>
sub perm_size_file {
  my ($perm, $size, $file) = @_;
  printf("%s%s%s%-19s%s%s\n", $d[0], $perm, $d[3], $size, $d[2], $file);
}

## view: permissions, time, size and filename
## <time> | <perm> | <filename>
sub time_perm_file {
  my ($perm, $rel, $file) = @_;
  printf("%s%s%s%s%s\n", $rel, $d[0], $perm, $d[3], $file);
}

## view: time, permissions, size and filename
## <time> | <perm> | <size> | <filename>
sub time_perm_size_file {
  my ($perm, $rel, $size, $file) = @_;
  printf("%s%s%s%s%s%s%s\n", $rel, $d[0], $perm, $d[3], $size, $d[2], $file);
}

## view: permissions, time, size and filename
## | <perm> | <size> | <filename>
sub perm_time_size_file {
  my ($perm, $rel, $size, $file) = @_;
  printf("%s %s%s%s%s%s%s%s\n", $d[0], $perm, $d[3], $rel, $d[2], $size, $d[2], $file);
}

## view: file to the right
## <var> | <filename>
sub right_file {
  my ($var, $file, $paddingright) = @_;
  printf("%${paddingright}s%s%s\n", $var, $d[2], $file);
}

sub left_file {
  my ($file, $size, $paddingleft) = @_;

  ## first row has a \e[0m
  $file =~ s/^\e\[0m//g;

  my ($esclen, $strlen) = (0, length($file));

  ## for each escape sequence, pad the length of it
  while($file =~ m/\e\[(.*?m)/g) {
    $esclen += length($1);
  }

  ## special symlink
  if($file =~ s/->/▻/) {
  	$esclen += 5;
  }

  my $padlen = $paddingleft - $strlen + $esclen;

  ## cut too long filenames
  if($padlen < 0) {
  	$file = substr($file, 0, $padlen-7);
  	$padlen = 0;
  	$file = $file . "...\e[0m";
  }

  # pad with spaces
  #$file = $file . ( ' ' x $padlen);
  $file = ( ' ' x $padlen) . $file;

  printf("%s%s%s\n", $file, $d[2], $size);
}




=pod

=head1 NAME

ls++ - colorized ls on steroids

=head1 USAGE

ls++ [view] (files)

=head1 DESCRIPTION

ls++ is what GNU ls would look like with extensive makeup applied.

=head1 OPTIONS

=head3 Views

  --pf    permissions, file
  --psf   permissions, size, file
  --tpf   time, permissions, file
  --tpsf  time, permissions, size, file (default)
  --ptsf  permissions, time, size, file

=head3 COLORS

  -ansi   use the standard ANSI colors

=head3 Documentation

  --help  show the help and exit
  --man   show the manpage and exit

=head1 HISTORY

I wanted to re-arrange the ls output just like one can do with the -printf
option to GNU find. Sadly, there are no -printf option available for ls, so I
threw together a quick hack called 'pilsner' that did what I wanted and nothing
more, nothing less. Not very useful to others.

Mattias Svanström crafted together the 'l' application which did basicly the
same thing but more elegant and with a nice twist; it calculated relative
mtimes.

I really liked that idea, but there were a couple of annoyances, so I forked the
project and added a configuration file, support for flags that'll control the
different views and possiblity to ignore certain files.

=head1 AUTHOR

Written by Magnus Woldrich

=head1 REPORTING BUGS

Report bugs to trapd00r@trapd00r.se

=head1 COPYRIGHT

Copyright (C) 2010 Magnus Woldrich

License GPLv2

=head1 SEE ALSO

B<l> <http://github.com/mmso/scripts>

=cut
