#!/usr/bin/perl
my $APP = 'ls++';
use vars qw($VERSION);
$VERSION = '0.402-dev';

#use strict;
#use warnings; #XXX unicode bug
#use utf8;
#use encoding 'utf8';
#use open qw(:std :utf8);
use Term::ExtendedColor qw(fg uncolor);
use Pod::Usage;
use Getopt::Long;
use Time::Local;

#use Devel::Comments;

our($opt);

if(not _init_config()) {;
  die "No configuration file found\n";
}

my $ls       = '/bin/ls';
my @ls_opts  = get_ls_cmdline();
my @ls_where = get_ls_where(@ARGV);

if(not isa_tty()) {
  system($ls, @ls_where);
  exit;
}


Getopt::Long::Configure(
  qw(
    pass_through
    no_auto_abbrev
  )
);

GetOptions(
  'pf'        => \$opt->{view_perm_file},
  'psf'       => \$opt->{view_perm_size_file},
  'ptsf'      => \$opt->{view_perm_time_size_file},
  'potsf'     => \$opt->{view_perm_owner_time_size_file},

  'm|man'     => sub { pod2usage(verbose => 3); },
  'h|help'    => sub { pod2usage(verbose => 1); },
  'v|version' => sub { print "$APP v$VERSION\n" and exit 0; },

);

my @ls_opts_cleaned;

for my $opt(@ls_opts) {
  if ($opt !~ /--(pf|psf|ptsf|pfs|fsp|fps|sfp|spf|pstf|sptf|pstf|ptsf|potsf)/) {
    push @ls_opts_cleaned, $opt;
  }
}
@ls_opts = @ls_opts_cleaned;

ls();

sub ls {
  my $view = shift // 'view_perm_size_file';
  my($perm, $hlink, $user, $group, $size, $seconds, $file, $rel);
  my($second, $minute, $hour, $time, $month, $day, $year, %mon2num); #for Mac OS

  open(my $ls, '-|', "$ls @ls_opts @ls_where")
    or die("Cant popen $ls: $!");

  while(my $line = <$ls>) {
    #total 1.7M
    next if $line =~ /^total/;


    # Assume GNU coreutils
    ($perm, $hlink, $user, $group, $size, $seconds) = split(/\s+/, $line)
      unless $line =~ /^\s/;

    ($file) = $line =~ m/[0-9]{10} (.+)$/;


    #if( (!$file) ) {
    #  next;
    #}
    if( ($ENV{DISPLAY}) || ($ENV{SSH_CLIENT}) ) {
      $file = add_ls_color($file);
    }

    # XXX
    #if(!defined($file)) { # ignored;
    #  next;
    #}

    my $symlink_attr = 'italic';
    if($ENV{TERM} =~ m/xterm/) {
      # NOTE xterm does not support italics
      $symlink_attr = '';
    }
    $file =~ s{ ->\s(.+) }{ fg($opt->{symlink_color}, $opt->{symlink_delimiter})
      . fg($symlink_attr, fg($opt->{symlink_color}, $1))
    }ex;

    $rel  = relative_time(time(), $seconds);
    $perm = perm($perm);
    $size = size($size);

    $size =~ s/^\s{3}(.+)/$1 /;

    my $user = owner($user, $group);

    if($opt->{view_perm_file}) {
      view_perm_file($perm, $file);
      next;
    }
    elsif($opt->{perm_time_file}) {
      perm_time_file($perm, $rel, $file);
      next;
    }
    elsif($opt->{view_perm_size_file}) {
      view_perm_size_file($perm, $size, $file);
      next;
    }
    elsif($opt->{view_perm_owner_time_size_file}) {
      view_perm_owner_time_size_file($perm, $user, $rel, $size, $file);
      next;
    }
    else {
      view_perm_time_size_file($perm, $rel, $size, $file);
      next;
    }
  }
}

sub add_ls_color {
  my $file = shift;

  for my $pattern(keys(%{$opt->{ls_color}})) {
    if($opt->{ls_color}->{$pattern} eq 'IGNORE') {
      next;
    }
    my $no_ls_color_file = uncolor($file);

    if($no_ls_color_file =~ /$pattern/) {
      $file = $no_ls_color_file;
      $file = fg($opt->{ls_color}->{$pattern}, $file);
    }
  }
  return $file;
}

sub view_perm_file {
  my ($perm, $file) = @_;
  printf("%s%s%s%s%s%s%s%s%s%s\n",
    fg($opt->{color}->{separator}, $opt->{separator}),
    $perm,
    fg($opt->{color}->{separator}, $opt->{separator}),
    $file,
  );
}


sub view_perm_time_size_file {
  my ($perm, $rel, $size, $file) = @_;
  printf("%s%s%s%s%s%s%s%s\n",
    fg($opt->{color}->{separator}, $opt->{separator}),
    $perm,
    fg($opt->{color}->{separator}, $opt->{separator}),
    $rel,
    fg($opt->{color}->{separator}, $opt->{separator}),
    $size,
    fg($opt->{color}->{separator}, $opt->{separator}),
    $file,
  );
}

sub view_perm_owner_time_size_file {
  my ($perm, $user, $rel, $size, $file) = @_;
  printf("%s%s%s%s%s%s%s%s%s%s\n",
    fg($opt->{color}->{separator}, $opt->{separator}),
    $perm,
    fg($opt->{color}->{separator}, $opt->{separator}),
    $user,
    fg($opt->{color}->{separator}, $opt->{separator}),
    $rel,
    fg($opt->{color}->{separator}, $opt->{separator}),
    $size,
    fg($opt->{color}->{separator}, $opt->{separator}),
    $file,
  );
}

sub view_perm_size_file {
  my($perm, $size, $file) = @_;
  if(length($size) == 37) {
    $size .= '';
  }
    elsif(length($size) == 24) {
      $size = "            $size            ";
    }
  printf("%s%s%s%s%s%s%s%s\n",
    fg($opt->{color}->{separator}, $opt->{separator}),
    $perm,
    fg($opt->{color}->{separator}, $opt->{separator}),
    $size,
    fg($opt->{color}->{separator}, $opt->{separator}),
    $file,
  );
}

sub perm {
  my ($perm) = @_;

  $perm =~ s/-/$opt->{delimiter}/g;
  $perm =~ s/(r)/fg($opt->{color}->{perm_read},    $1)/eg;
  $perm =~ s/(w)/fg($opt->{color}->{perm_write},   $1)/eg;
  $perm =~ s/(x)/fg($opt->{color}->{perm_execute}, $1)/eg;

  $perm =~ s/(d)/fg($opt->{color}->{perm_dir},  fg('bold', $1))/eg;
  $perm =~ s/(l)/fg($opt->{color}->{perm_link}, fg('bold', $1))/eg;
  $perm =~ s/(s)/fg($opt->{color}->{perm_suid}, fg('bold',  $1))/eg;
  $perm =~ s/(S)/fg($opt->{color}->{perm_guid}, fg('bold', $1))/eg;
  $perm =~ s/(t)/fg($opt->{color}->{perm_sticky}, $1)/eg;
  $perm =~ s/(T)/fg($opt->{color}->{perm_stickybig}, fg('bold', $1))/eg;

  return $perm;
}

sub owner {
  my ($user, $group) = @_;
  $user  = fg($opt->{color}->{user},  $user);
  $group = fg($opt->{color}->{group}, $group);

  return $user . ':'. $group;
}

sub size {
  my ($size) = @_;

  #warn "SIZE len is " . length($size), "\n";

  #FIXME
  if($size =~ m/^(\S+)(K)/) {
    $size = sprintf("% 27s",
      fg($opt->{color}->{kilobyte}, sprintf("% 4g", $1))
      . fg($opt->{color}->{kilobyte}, fg('bold', $2))
    );
  }
  elsif($size =~ m/^(\S+)(M)/) {
    $size = sprintf("% 29s",
      fg($opt->{color}->{megabyte}, sprintf("% 4g", $1))
      . fg($opt->{color}->{megabyte}, fg('bold', $2))
    );
  }
  elsif($size =~ m/^(\S+)(G)/) {
    $size = sprintf("% 27s",
      fg($opt->{color}->{gigabyte}, sprintf("% 4g", $1))
      . fg($opt->{color}->{gigabyte}, fg('bold', $2))
    );
  }
  elsif($size =~ m/^(\d+)/) {
    if($1 == 0) {
      $size = sprintf("% 29s",
      fg($opt->{color}->{empty}, fg('bold', sprintf("% 4s", '-')))
      . fg($opt->{color}->{byte}, fg('bold', 'B'))
    );
    }
    else {
      $size = sprintf("% 29s",
        fg($opt->{color}->{byte}, sprintf("%4d", $1))
        . fg($opt->{color}->{byte}, fg('bold', 'B'))
      );
    }
  }
  return $size;
}



sub relative_time_format {
  my ($color, $string, $unit) = @_;
  # XXX
  return sprintf("%s%-3s%-2s", $color, $string, $unit);
}



sub relative_time {
  my ($cur, $sec) = @_;
  my $delta = $cur - $sec;
  my ($unit, $ret);

  ## 0 < sec < 60
  $unit = "sec ";
  $ret = $delta;

  return relative_time_format(fg($opt->{color}->{sec}), "<", $unit)
    if $delta < 10;
  return relative_time_format(fg($opt->{color}->{sec}), $ret, $unit)
    if $delta < 60;

  ## 1 < min < 45
  $unit = "min ";
  $ret = int($ret/60);

  # XXX
  return relative_time_format(fg($opt->{color}->{min}), "<", $unit)
    if $delta < 2 * 60;
  return relative_time_format(fg($opt->{color}->{min}), $ret, $unit)
    if $delta < 45 * 60;

  ## 0.75 < hour < 42
  $unit = "hour";
  $ret = int($ret/60);

  return relative_time_format(fg($opt->{color}->{hour}), "<", $unit)
    if $delta < 90 * 60;
  return relative_time_format(fg($opt->{color}->{hour}), $ret, $unit)
    if $delta < 24 * 60 * 60;
  return relative_time_format(fg($opt->{color}->{hour}), $ret, $unit)
    if $delta < 30 * 60 * 60;
  return relative_time_format(fg($opt->{color}->{hour}), $ret, $unit)
    if $delta < 36 * 60 * 60;

  ## 0.75 < day < 30
  $unit = "day ";
  $ret = int($ret/24);

  return relative_time_format(fg($opt->{color}->{day}), "<", $unit)
    if $delta < 48 * 60 * 60;
  return relative_time_format(fg($opt->{color}->{day}), $ret, $unit)
    if $delta < 7 * 24 * 60 * 60;
  return relative_time_format(fg($opt->{color}->{day}), $ret, $unit)
    if $delta < 14 * 24 * 60 * 60;
  return relative_time_format(fg($opt->{color}->{day}), $ret, $unit)
    if $delta < 28 * 24 * 60 * 60;
  return relative_time_format(fg($opt->{color}->{day}), $ret, $unit)
    if $delta < 30 * 24 * 60 * 60;

  ## 1 < month < 12
  $unit = "mon ";
  $ret = int($ret/30);

  return relative_time_format(fg($opt->{color}->{month}), "<", $unit)
    if $delta < 2 * 30 * 24 * 60 * 60;
  return relative_time_format(fg($opt->{color}->{month}), $ret, $unit)
    if $delta < 12 * 30 * 24 * 60 * 60;

  ## 1 < years < inf
  $unit = "year";
  $ret = int($ret/12);

  return relative_time_format(fg($opt->{color}->{year}), $ret, $unit);
}


#sub _get_color_support {
#  my $colors = 8;
#  if(!($ENV{DISPLAY})) {
#    $colors = 16;
#    return $colors;
#  }
#  if(
#    $ENV{TERM} eq 'xterm'
#      or($ENV{TERM} eq 'xterm-256color') # What Mac OS Lion terminal pretends to be
#      or($ENV{TERM} eq 'rxvt-256-color')
#      or($ENV{TERM} =~ /screen-256/)
#      or($ENV{TERM} eq 'Eterm-256color')
#      or($ENV{TERM} eq 'gnome-256color')
#      or($ENV{TERM} eq 'konsole-256color')
#      or($ENV{TERM} eq 'putty-256color')
#      or($ENV{TERM} eq /rxvt-unicode-256color/)
#      or($ENV{TERM} =~ /u?rxvt-256color/)
#  ) {
#    $colors = 256;
#  }
#  elsif($ENV{TERM} eq 'rxvt-unicode') {
#    $colors = 88;
#  }
#  elsif($ENV{TERM} eq 'screen') {
#    $colors = 8;
#  }
#  else {
#    chomp($colors = `tput colors`); # fail silently
#  }
#
#  return $colors;
#}


sub _init_config {
  my $config;

  if($ENV{DEBUG}) {
    require('./ls++.conf');
    print "Using ./ls++.conf\n" unless $@;
  }

  my @locations = (
    "./ls++.conf",
    "$ENV{XDG_CONFIG_HOME}/ls++/ls++.conf",
    "$ENV{HOME}/.config/ls++/ls++.conf",
    "$ENV{HOME}/.ls++.conf",
    "$ENV{HOME}/.ls++/ls++.conf",
    "/etc/ls++.conf",
  );

  for my $conf(@locations) {
    if(-f $conf) {
      require $conf;
      if($@) {
        next;
      }
      return 1;
    }
  }
  return 0;
}


sub isa_tty {
  return 1 if -t STDOUT;
  return 0;
}

sub get_ls_where {
  my @files;
  for(@_) {
    if(-e $_) {
      push(@files, escape($_));
    }
    else {
      push(@ls_opts, $_);
    }
  }
  return (wantarray()) ? @files : scalar(@files);
}


sub get_ls_cmdline {
  return $opt->{ls_cmdline};
}

sub escape {
  my $p = shift;
  $p =~ s/([;<>*|`&\$!#()[\]{}:'" ])/\\$1/g;
  return $p;
}

__END__


=pod

=head1 NAME

ls++ - colorized ls on steroids

=head1 USAGE

ls++ [VIEW..] [OPTIONS..] [FILE]

=head1 DESCRIPTION

ls++ is what GNU/BSD ls would look like with extensive makeup applied.

=head1 OPTIONS

=head3 Views

  --pf    permissions, file
  --psf   permissions, size, file
  --ptsf  permissions, time, size, file
  --potsf permissions, owner, time, size, file

=head3 Documentation

  --help  show the help and exit
  --man   show the manpage and exit

Not known parameters will be passed through to B<ls>, so to show hidden files,
C<-a> or C<-A> might be added. See ls(1) for more information.

=head1 HISTORY

I wanted to re-arrange the ls output just like one can do with the -printf
option to GNU find. Sadly, there are no -printf option available for ls, so I
threw together a quick hack called 'pilsner' that did what I wanted and nothing
more, nothing less. Not very useful to others.

Mattias Svanström crafted together the 'l' application which did basicly the
same thing but more elegant and with a nice twist; it calculated relative
mtimes.

I really liked that idea, but there were a couple of annoyances, so I forked the
project and added a configuration file, support for flags that'll control the
different views and possiblity to ignore certain files amongst other things.

=head1 AUTHOR

  Magnus Woldrich
  CPAN ID: WOLDRICH
  magnus@trapd00r.se
  http://japh.se

=head1 CONTRIBUTORS

The relative time calculations is made by Mattias Svanström.

crshd added optional user:group display.

=head1 COPYRIGHT

Copyright 2010, 2011 the B<ls++> L</AUTHOR> and L</CONTRIBUTORS> as listed
above.

=head1 LICENSE

This application is free software; you may redistribute it and/or modify it
under the same terms as Perl itself

=head1 SEE ALSO

L<ls++.conf(1)>

L<ls(1)>

L<l|http://github.com/mmso/scripts>

=cut
